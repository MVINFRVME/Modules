# Задача 5. Кэширование для ускорения вычислений
# Контекст
# Вы разрабатываете программу для оптимизации вычислений чисел Фибоначчи. Числа Фибоначчи вычисляются рекурсивной
# функцией, каждое число равно сумме двух предыдущих чисел. Однако вы заметили, что при больших значениях чисел
# Фибоначчи вычисления занимают значительное время, так как многие значения вычисляются повторно. Вам поручено
# создать декоратор, который кэширует результаты вызова функции и позволяет избежать повторных вычислений для одних
# и тех же аргументов.

# Задача
# Создайте декоратор, который кэширует (сохраняет для дальнейшего использования) результаты вызова функции и, при
# повторном вызове с теми же аргументами, возвращает сохранённый результат.

# Примените его к рекурсивной функции вычисления чисел Фибоначчи.

# В итоге декоратор должен проверять аргументы, с которыми вызывается функция, и, если такие аргументы уже
# использовались, должен вернуть сохранённый результат вместо запуска расчёта.

# Советы
# Для хранения результатов удобно использовать словарь, так как поиск элементов внутри словаря будет иметь сложность,
# равную в среднем O(1).
# При этом не стоит хранить все вычисления в одном словаре, созданном снаружи функций (в глобальной области видимости).
# Лучше создавать отдельные словари для каждой декорируемой функции.

from typing import Callable
from functools import wraps


def casher(func: Callable) -> Callable:
    """Декоратор casher, который кэширует результаты вызова функции и позволяет
     избежать повторных вычислений для одних и тех же аргументов """
    cash = {}

    @wraps(func)
    def wrapper(*args, **kwargs):
        if args in cash:
            result = cash[args]
        else:
            result = func(*args, **kwargs)
            cash[args] = result
        return result
    return wrapper


# @casher
def fibonacci(number: int) -> int:
    """Функции вычисления чисел Фибоначчи при помощи рекурсии."""
    if number <= 1:
        return number
    return fibonacci(number - 1) + fibonacci(number - 2)


print(fibonacci(4))
print(fibonacci(4))
print(fibonacci(5))
print(fibonacci(10))
print(fibonacci(50))

# ok
# посмотрел насколько дольше работает без декоратора?) В functools, есть похожмй декоратор lru_cache
