# Задача 1. Работа с файлом 2
# Что нужно сделать
# Реализуйте модернизированную версию контекст-менеджера File:

# Теперь при попытке открыть несуществующий файл менеджер должен автоматически создавать и открывать этот файл в
# режиме записи;
# на выходе из менеджера должны подавляться все исключения, связанные с файлами.
# Что оценивается
# Результат вычислений корректен.
# Модели реализованы в стиле ООП, основной функционал описан в методах классов и отдельных функциях.
# При написании классов соблюдаются основные принципы ООП: инкапсуляция, наследование и полиморфизм.
# Для получения и установки значений приватных атрибутов используются сеттеры и геттеры с соответствующими декораторами.
# Для создания нового класса на основе уже существующего используется наследование.
# Для статических и классовых методов используется декоратор classmethod.
# Сообщения о процессе получения результата осмысленны и понятны для пользователя.
# Переменные, функции и собственные методы классов имеют значащие имена (не a, b, c, d).
# Классы и методы/функции имеют прописанную документацию.
# Есть аннотация типов для методов/функций и их аргументов (кроме args и kwargs). Если функция/метод ничего не
# возвращает, то используется None.

from typing import Optional


class File:
    """Контекстный-менеджер File, который открывает указанный файл, а затем закрывает его.
    В случае, если указанный файл не существует, файл менеджер создает его и открывает в
    режиме записи. Также на выходе из менеджера подавляются все исключения, связанные с
    файлом.

    Args:
        file_name (str): Имя файла
        mode (str): Режим для работы с файлом

    """

    def __init__(self, file_name: str, mode: str) -> None:
        self.file_name = file_name
        self.mode = mode
        self.file = None

    def __enter__(self) -> 'File':
        try:
            self.file = open(self.file_name, self.mode, encoding='utf-8')
        except FileNotFoundError:
            self.file = open(self.file_name, 'w', encoding='utf-8')
        return self.file

    def __exit__(self, exc_type, exc_val, exc_tb) -> Optional[bool]:
        self.file.close()
        if exc_type:  # Можно и без этого блока кода,но оставил для наглядоности.
            return True


with File('Note.txt', 'r') as file:
    file.write('Привет')
